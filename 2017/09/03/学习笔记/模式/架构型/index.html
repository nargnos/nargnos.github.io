<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="模式," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="不全待补">
<meta name="keywords" content="模式">
<meta property="og:type" content="article">
<meta property="og:title" content="[模式] 架构型">
<meta property="og:url" content="/2017/09/03/学习笔记/模式/架构型/index.html">
<meta property="og:site_name" content="{S}">
<meta property="og:description" content="不全待补">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-11T12:22:31.842Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[模式] 架构型">
<meta name="twitter:description" content="不全待补">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"hide","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="/2017/09/03/学习笔记/模式/架构型/"/>





  <title>[模式] 架构型 | {S}</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">        
        <span class="site-title logo-font">{S}</span>  
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i>
            
            
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i>
            
            
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i>
            
            
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="/2017/09/03/学习笔记/模式/架构型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nargnos">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="{S}">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[模式] 架构型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T16:55:42+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/模式/" itemprop="url" rel="index">
                    <span itemprop="name">模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  不全待补
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>体系结构模式表示软件系统的基本结构化组织。它提供一套预定义的子系统，规定它们的职责，并包含用于组织它们之间关系的规划和指南。</p>
<p><em>这类模式不应该跟设计模式放到一起（因为框架是大局观，设计模式是操作方法，惯用法是操作细节），因为我不想分得太细（会造成某个分类文档过少），而且wiki上的模式分类和一些书上的分类有冲突，也不好判定谁对谁错，所以就混在一起放。</em><br><em>看的这本书翻译也有问题，大部分语句都需要猜它原本想要表达的是什么。</em><br><br></p>
<h1 id="从混乱到有序"><a href="#从混乱到有序" class="headerlink" title="从混乱到有序"></a>从混乱到有序</h1><p>将混乱的结构组织成可移植、可维护、可理解和稳定的结构。</p>
<hr>
<h2 id="层次（Layers）"><a href="#层次（Layers）" class="headerlink" title="层次（Layers）"></a>层次（Layers）</h2><p>多层（Multitier/n-tier/multilayered）<br>用于分解大系统</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>有助于构建可以被分子任务组，且每个子任务组处于一个特定的抽象层次之上的程序。  </p>
<p>比如网络协议的分层，或者在介绍框架时一般会附带一张结构图，基本都是层次结构。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将系统分层，按次序排列，底层是系统基础，其上的每一层都只用到下一层提供的抽象（没有更进一步的直接依赖关系），直到顶层。在某一层中用到的所有组件都工作在同一个抽象层。每个独立层都要防止较高层直接访问较低层。    </p>
<p>在使用时向顶层发送请求，如果不能完成这个请求该层就向下传递，直到底层；在请求处理完成后，便一层层向上传递回顶层。在传递时可以判断这个事件是否应该继续往下传递，如果不需要，可向上层返回处理结果。可以在某一层缓存请求结果，这样在请求传递时可以检查缓存直接返回结果，而不需要传递到底层。<br>也可以像网络协议那样使用，每一层附加一些解析信息，一层层添加完毕后传递给其它对象，再一层层解析出来。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以用以下步骤构建，但不是所有步骤都是必须的：</p>
<ol>
<li>定义分层的抽象准则</li>
<li>根据抽象准则定义抽象层数</li>
<li>给每个层命名并指定其职责    </li>
<li>指定服务<br> 把较多服务放到高层更好，注意层之间要严格分离，但如果需要共享模块（数据定义等）可以不那么严格。</li>
<li>细化分层<br> 重复之前的步骤，直到得到一种自然稳定的分层。</li>
<li>为每个层指定一个接口<br> 尽可能的把这些接口封装在一个外观对象之中。</li>
<li>构建独立层<br> 如果独立层很复杂，可以用桥接或者策略模式来构建。</li>
<li>指定相邻层间的通信<br> 常用的是推模式。当请求下层服务时使用。也可以用拉模式，可以使低层自行从高层获取可用信息。</li>
<li>分离邻接层<br> 请求自顶向下传输时，可用返回值传输结果。当自底向上通信时，可以用回调来获得相关数据。如果消息需要向上又要向下传输，明确把低层连接到高层更好。</li>
<li>设计一种错误处理策略<br>对于分层结构，错误处理在处理时间和编程工作方面的代价较大。尽可能的在低层处理错误，防止高层被许多不同错误和大量错误代码搞复杂。把相似的错误类型归类，注意错误类型是否需要设置成所有层共享，否则高层可能无法理解低层抽象的错误信息。</li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>当性能比可维护性重要且接口稳定时，可以使用松散的分层结构，就是允许高层直接访问所有低层的服务，而不是只访问邻接层。  </p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>层重用、标准化支持、局部依赖性、可替换性</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>层的行为改变时可能要在一些层上做一些重复工作以合并局部改动。<br>分层会存在粒度大小的问题，需要合理分层。<br>性能不高，因为需要在层之间传递数据。</p>
<h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>最广泛使用的多层结构。  </p>
<p><strong>一般</strong>分为</p>
<ul>
<li>表现层（UI）：最顶层，直接与用户交互的界面，用于接受输入和显示数据。</li>
<li>业务逻辑层（BLL）：中间层，用于连接DAL和UI，实现业务逻辑，实现程序功能；务逻辑具体包含：验证、计算、业务规则等。</li>
<li>数据访问层（DAL）：底层，操作数据库并提供相应API。</li>
</ul>
<p>各层之间用实体类（Model）进行通信，每一层都需要引用它。实体类就是对数据的映射，是存储数据的对象。<br>数据流向为 UI-&gt;BLL-&gt;DAL(处理并返回数据)-&gt;BLL-&gt;UI</p>
<hr>
<h2 id="管道和过滤器（Pipes-and-Filters）"><a href="#管道和过滤器（Pipes-and-Filters）" class="headerlink" title="管道和过滤器（Pipes and Filters）"></a>管道和过滤器（Pipes and Filters）</h2><p>用于处理数据流</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>为处理数据流的系统提供了一种结构：每个处理步骤封装在一个过滤器组件中，数据通过相邻过滤器之间的管道传输，重组过滤器可以建立相关系统族。</p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>在创建处理或转换输入数据流的系统时，需要把任务分解成几个阶段，而且需求容易变动，可以用这个模式解决。<br>把系统任务分成几个顺序的步骤，步骤间采用数据流连接（前一个步骤输出是下一个步骤输入），每个步骤由一个过滤器组件实现。<br><strong>过滤器</strong>在产生任何输出之前会将它的输入全部处理，系统的输入由数据源提供，输出会被存储到数据汇点（比如文件什么的），这些过滤器、数据源、数据汇点由管道顺序连接，每个管道处理步骤间的数据流动。通过管道连接的过滤器序列叫处理流水线（Processing pipeline）。</p>
<p>过滤器是流水线的处理单元，它可以丰富、提炼、转换它的输入数据。<br>流水线可以等待数据流入或者主动从连一个流水线拉出数据（推拉模型）。<br>可以用循环的方式工作，从流水线取得输入数据并将输出数据输出流水线。<br>可以将流水线设计为一个独立的程序或线程。  </p>
<p><strong>管道</strong>用来处理它们之间的连接，不过如果过滤器用推模型实现的话，在管道中需要调用相关的函数，会使过滤器重组更加困难。<br>管道可以设置一个缓冲区，如果过滤器是独立的线程，还可以将管道设计为一个队列用来同步。  </p>
<p><strong>数据源</strong>是系统的输入，可以主动将数据推入第一个处理阶段，也可以在第一个过滤器拉取数据时提供数据。</p>
<p><strong>数据汇点</strong>收集流水线的结果，可以主动的把结果拉取出来，也可以被动的等前面的过滤器推送结果。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>可以使用系统服务（如消息队列或管道）来连接管道（指的是模式中的管道）或者可以直接调用，使用不同的方式连接会有不同的实现步骤。<br>一般步骤如下：</p>
<ol>
<li>把系统任务分成一系列处理步骤<br> 每个步骤只依赖前一步骤的输出，通过数据流将所有步骤相连。</li>
<li>定义管道传输的数据格式<br> 统一的格式使重组过滤器变得更灵活。如果需要不同的数据格式，可以创建一个转换过滤器来对数据进行转换。另外还需要定义结束标识，可以用一个特殊值来表示结束。</li>
<li>决定如何实现管道连接<br> 决定是用主动还是被动的形式（推拉模型）使用过滤器，如果统一形式，可使过滤器能随意重组。可以用系统的一些机制实现。</li>
<li>设计和实现过滤器<br> 过滤器可用推拉模型实现，可以放到单独的线程中运行。如果需要拷贝数据，可以在管道内设置缓冲区。可以定义全局环境、数据仓库或配置文件供过滤器使用。</li>
<li>设计错误处理策略<br> 流水线组件不能共享任何全局状态，所以当发生错误时不好处理。可以定义一个特殊管道输出错误（类似stderr）。或者在过滤器发现错误时忽略输入直到下一个分隔点，或者引入特殊标记值来给数据流做标记。捕获到错误时可以重启流水线或者等待有正确的输入再继续处理。</li>
<li>建立处理流水线<br> 可以将中间结果存储在文件中，并将文件作为流水线输入，这样可以支持流水线增量式开发。</li>
</ol>
<h3 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h3><p>过滤器可以不止一个输入或一个输出。<br>可用并行来提高处理效率。  </p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>增加灵活性</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>过滤器之间传输数据在转换时有额外开销，错误处理是这个模式的弱点，如果流水线在处理时不可重启或不可忽略错误时应该换另一种模式。</p>
<hr>
<h2 id="黑板（Blackboard）"><a href="#黑板（Blackboard）" class="headerlink" title="黑板（Blackboard）"></a>黑板（Blackboard）</h2><p>可作为行为树的辅助模块使用。</p>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>对于无确定性求解策略的问题比较有用。在这个模式中有几个专用子系统收集信息并建立一个可能的局部解或近似解。  </p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>当需要做一个决策的时候，需要输入一些外部信息，如果为每个外部信息都设置一个接口，会导致接口复杂，把这堆数据集中在一个数据结构中处理，可以使调用简单化而且可使使用者更像一个黑盒。<br>其思想是多个独立程序集共享一个数据，可以放入不同的数据供感兴趣的程序使用。</p>
<p>针对的是那些在把原始数据转换为高层数据结构方面没有可行的确定解的问题，这些问题常常出现在一些不成熟的领域，其中没有相近的已知方法或可行的方法。<br>将一个问题分解成若干子问题时，部分问题需要跨几个领域的专业知识，并且需要不同的表示和泛型。许多情况不一定能产出最优解，有可能得到次优或没有解；有可能在给定时间无法搜索所有的解空间（所有可能解的集合），或者领域还不成熟。所以黑板系统需要仔细做文档，并且如果重要的决定需要依赖它的结果，必须验证这个结果。  </p>
<p>这个模式的思想是让多模块在一个<strong>公共数据结构</strong>上<strong>合作</strong>。每个程序用来解决整个任务中的一个<strong>特定部分</strong>，<strong>所有</strong>程序一起工作以解决问题。这些程序彼此独立但不相互调用，它们的活动也没有预先确定的顺序，系统的执行方向主要由当前状态决定。并设置有一个中心控制组件评估处理当前状态，协调各个程序。</p>
<p>在求解过程中，系统通过将求解方案组合、更改、否定来工作。每一个解表示一部分问题和其解法的一个阶段，解空间被组织成几个抽象层次，最低层次由输入的一个内部表示构成，系统的潜在解决方案处于最高层。  </p>
<p>我的理解（可能不对）：由不同处理程序（知识源）读取黑板，每个程序收集需要的信息，然后产出解，更新到黑板；由控制器决定下一次由哪些程序处理，执行这个步骤几次后，黑板上就留下了问题的解。<br>相当于开始时把所有信息都写在黑板上，然后由多个有各自专长的专家（知识源）合作，各自收集需要的信息求解并更新黑板，这个过程需要有一个主导者来控制流程，所以需要一个控制组件。   </p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>把系统分成<strong>黑板</strong>组件和<strong>控制</strong>组件，黑板组件由<strong>知识源集合</strong>构成。<br>黑板是中心数据仓库，它提供了一些读写接口，存储的是解空间的元素和控制数据，黑板中出现的数据元素称为<strong>词汇</strong>。</p>
<p>解空间的所有元素都能出现在黑板上。<br>对于在求解过程中构建并放在黑板上的解，称为<strong>假设</strong>，后期被否定的假设要从黑板中删除。<br><strong>知识源</strong>是求解特定方面问题的独立子系统，它们一起模拟了整个问题域，它们中没有哪个能单独解决系统的任务。<br>知识源之间不直接交流，它只从黑板读写，所以它们需要理解黑板的词汇。知识源在两个抽象等级上起作用，如果它向前推理，就将解法转化成高层解法；如果反向推理，就要在低层搜索；如果推理过程不能得出结论，可以反向参考低等级解法。<br>知识源分成两个部分：</p>
<ul>
<li>条件部分：评估求解过程的当前状态，确定在黑板上的内容是否有用。</li>
<li>行动部分：生成能导致黑板内容改变的结果。</li>
</ul>
<p><strong>控制</strong>组件用循环监视黑板的改动并决定接下来采取什么动作。它根据知识应用策略根据黑板上的数据安排知识源评估和行动。<br>策略可以依赖控制知识源，这些知识源可产出控制决定，它们产出结果被保存在黑板上称为控制数据。  </p>
<p>黑板可能会有没有知识源可用的情况，在这种情况下，系统产出失败结果。在控制组件中有一个特定知识源或一个过程确定系统何时终止和结果内容，一旦找到一个可接受的假设或者空间、时间资源被耗尽时就停止系统。  </p>
<p>这个<a href="https://social.technet.microsoft.com/wiki/contents/articles/13461.blackboard-design-pattern-a-practical-example-radar-defense-system.aspx" target="_blank" rel="external">例子</a>可能会有助于理解。  </p>
<p>一些地方说可以用key-value的形式实现。</p>
<p>在实现时需要执行以下步骤：</p>
<ol>
<li>定义问题</li>
<li>定义问题解空间</li>
<li>将求解过程分成几个步骤<br> 定义解如何转换成高等级解决方案，描述在同一抽象等级上如何得出假设，细化如何从其它等级中找出能验证假设的数据，详细指明可用于排除部分解空间的知识类型。</li>
<li>把知识分成和子任务相关的特定领域知识</li>
<li>定义黑板的词汇<br> 详细拟定解空间的最初定义和解的抽象等级。找到解的一种表示，使所有知识源可从黑板上读取并产出，每个知识源必须能确定它是否能用这个假设（它可以不理解这个假设，但必须确定是否能用）。如果有必要可以提供假设和知识源内部表示之间的转换。<br> 为了评估黑板的内容，控制组件必须能理解词汇，所以词汇不能只定义一次，它需要随知识源和控制组件的定义一起进化。在设计过程的某些节点上，词汇必须稳定，并且允许知识源稳定接口的开发。  </li>
<li>确定系统的控制策略<br> 需要判断一个假设的可信度（可以在0~100之间），删除低可信度的假设。<br> 把对黑板的改动分为两种类型。一种是新的可用知识源，另一种是其它改动，这时候控制组件选择一个未对所有条件调用的知识源（这里翻译有问题，猜不出在说什么）。<br> 黑板的关联种类随可用的知识源一同改动。使用队列来保存知识源的有价值信息，并用优先级来排列可应用知识源。如果控制组件有复杂和独立的子任务，则为每个子任务定义控制知识源。</li>
<li>实现知识源<br> 将知识源分成条件、动作两部分。可在同一系统中用不同技术来实现知识源。</li>
</ol>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>可使用不同算法来搜索解空间，知识源可重用</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>测试困难，不能保证有解，低效，开发麻烦，缺少对并行机制的支持</p>
<hr>
<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="代理者（Broker）"><a href="#代理者（Broker）" class="headerlink" title="代理者（Broker）"></a>代理者（Broker）</h2><p>用于带有独立协作组件的分布式（可能是异构）系统。</p>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>可以用于构建带有隔离组件的分布式软件系统，通过远程服务调用进行交互，负责协调通信（比如转发请求、传递结果和异常）。</p>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>构建一个复杂的软件系统，它是独立和可互操作的组件集合而不是一个整体程序，从而有较大灵活性、可维护性和可变更性。通过将功能分割成独立组件，让系统变得可分布和可扩展。  </p>
<p>当分布式组件相互通信时需要一些进程间通信机制，如果组件自身处理通信，最终系统会依赖所使用的通信机制；这些服务器程序不应该依赖特定的系统细节以确保在异构网络中的可移植性和互操作性。  </p>
<p>引入代理者可较好地做到客户机和服务器的隔离。<strong>服务器</strong>向代理者<strong>注册</strong>自己，使其服务通过方法接口能被客户机所使用；<strong>客户机通过代理者发送</strong>请求访问服务器功能。代理者的任务包括<strong>定位</strong>合适的服务器，将请求<strong>转发</strong>到服务器并向客户机<strong>回送</strong>结果和异常。</p>
<p>这个模式降低了开发分布式程序的复杂性，应用程序能够简单地通过向合适的对象发出消息调用访问分布式服务，而不是把重点放在低级进程间通信，并允许对象动态改变、添加、删除和重定位。  </p>
<p>代理者提供了分布技术和对象技术，它也将对象模型从单一程序扩展到运行在异构机器上并可用不同语言来编写的分布式应用程序。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>参与组件：</p>
<ul>
<li>服务器：实现通过接口展示功能的对象，这些接口通过接口定义语言（IDL）或二进制标准来获得，有两种类型的服务器：<ul>
<li>为许多应用领域提供公共服务的服务器</li>
<li>为单一应用域或任务实现特定功能的服务器</li>
</ul>
</li>
<li>客户机：访问至少一台服务器的服务的应用程序，它通过代理者转发请求，在操作执行后，他们将收到来自代理者的应答。客户机与服务器之间的互操作基于一种动态模型，它意味着服务器也可以做客户机，它们之间的关系并不是静态定义好的。客户机不必知道服务器的位置，这可以允许在系统运行期间增加或移动服务。  </li>
<li>代理者：负责在客户机和服务器之间传送消息的信使。它需要某种手段定位消息接收者（如唯一标识符）。它需要向客户机和服务器提供用来注册服务器和调用服务器方法的API。<br>  当请求发送到本地代理者（允许在当前机器，远程的运行在远程节点）维护的一个服务器时，代理者将直接把请求传送到服务器。如果服务器未激活则将其激活；应答会由代理者转发到发出请求的客户机。如果指定的服务器由另一个代理者代理，则本地代理者将寻找一条到远程代理者的路径并用该路径转发请求，这就需要代理者能互操作。  </li>
<li>客户机端代理：代表客户机和代理者之间的一个层，用来隐藏通信机制。</li>
<li>服务器端代理：与上面相似，不过它负责接受请求，解析消息并调用适当的服务。</li>
<li>网桥（Bridge）：可选，用来隐藏两个代理者互操作时的实现细节。它可将特定系统细节封装。</li>
</ul>
<p>有两种类型的代理者系统：直接通信、间接通信。<br>为了较好的性能，一些代理者仅建立客户机和服务器间的通信链，剩下的通信由参与的组件之间直接进行（直接传送而不需要中间层）。这种方法需要双方使用相同的协议。<br>定义一个对象模型，服务器对象的状态及方法不应该被客户机直接访问，客户机仅能通过本地代理者传送请求间接改变或读取服务器的状态。  </p>
<p>实现时可遵循以下步骤：</p>
<ol>
<li>使用现有或定义一个对象模型<br> 需要描述服务器对象状态的定义、方法定义、怎样选择执行的方法和服务器对象如何产生和销毁，这些状态不应该直接被客户机访问，客户机仅能通过本地代理者传送请求以间接改变或读取服务器状态。</li>
<li>确定系统应该提供哪种组件互操作性<br> 可以用二进制标准或引入IDL来设计互操作性（展示接口），二进制标准可以用指针来获得接口，或者用IDL可以在其它编程语言上实现；这两种方法也可以结合使用。</li>
<li>指定代理者组件提供客户机与服务器合作的API<br> 客户机必须提供构建、发送请求和接收回应等功能。<br> 服务器实现的API主要是向代理者注册。代理者使用仓库来维护信息，仓库可以是外部文件，这样服务器就可以在系统启动前注册自己。另一种方式是把仓库作为代理者的内部组成，这样代理者必须允许服务器在运行期间注册并提供相应的API。代理者需要在请求到达时确认这些服务器，因此代理者的服务器端API必须能产生系统唯一标识符。  </li>
<li>用代理对象来对客户机和服务器隐藏实现细节<br> 客户机端代理对象将进程调用封装为消息并发送到本地代理者组件，并从本地代理者接受回应和异常并转发到客户机。<br> 服务端代理对象接受本地代理者请求并调用相应服务器的接口，并将回应打包返回到本地代理者。<br> 代理对象通过自身进程间通信机制与代理者通信，以隐藏实现细节。  </li>
<li>在设计API和代理对象同时设计代理者组件<br> 某些实现不通过代理者传递信息，这部分工作就由代理对象完成，但是代理者仍负责建立客户机与服务器之间的通信链。<br> 在设计和实现期间，需要重复如下步骤：<ul>
<li>指定与客户端代理和服务器端代理交互的协议</li>
<li>本地代理者必须对每台机器可用</li>
<li>系统必须记住由哪一个客户机发送请求，从而能把结果发送回去</li>
<li>如果代理对象没有提供对参数和结果的编组和复组机制，就必须将该功能包含在代理者中</li>
<li>如果需要异步通信，则可以在代理者或者代理中提供缓冲区</li>
<li>代理者使用目录服务将本地服务器标识符和物理地址关联起来，如果使用tcp/ip，可以使用端口号作为其地址。</li>
<li>当要求唯一标识符在服务器注册期间动态产生时，代理者需要提供产生标识符的机制</li>
<li>如果要支持动态调用，代理者需要有维护服务器类型信息的机制</li>
<li>注意失败的情况，一种是错误结果，一种是通信失败。有些代理者重复发送请求或回应多次直到成功，但需要保证请求仅执行一次，即使被再次发送。另外还要注意客户机试图访问不存在或没有权限访问的服务器的情况。注意要有完善的错误处理，否则测试和调试时会十分麻烦。  </li>
</ul>
</li>
<li>开发IDL编译器<br> 需要用编译器将接口定义转化为程序代码</li>
</ol>
<p>对于直接通信的代理者系统，代理者告诉客户机服务器提供了哪一条通信通道，从而客户机可以建立与指定服务器之间的连接。<br>如果以传输数据为重点的话，需要在原始数据附加消息类型、结构和其它相关额外信息。  </p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>定位透明性，CS之间互相不必关心对方位置</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>容错性较差，如果代理者或者服务器失效，依赖于它的程序都不能成功地继续进行，可以通过复制组件来提高可靠性。</p>
<hr>
<h1 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h1><p>保持内核功能独立于用户接口，因为内核功能通常保持稳定，用户接口常常需要变化。  </p>
<h2 id="模型-视图-控制器（Model-View-Controller，MVC）"><a href="#模型-视图-控制器（Model-View-Controller，MVC）" class="headerlink" title="模型-视图-控制器（Model-View-Controller，MVC）"></a>模型-视图-控制器（Model-View-Controller，MVC）</h2><p>这个<strong>模式</strong>在web开发用得比较多，但是也可在其它情况使用。<br>这个也是分为三层，不过跟三层架构的一般分法不同，需要注意。<br>用于需要具有灵活的人机接口的交互式程序。 </p>
<h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>将一个交互式应用程序分为三个组件。模型包含核心功能和数据，视图向用户显示信息，控制器处理用户输入。视图和控制器共同构成用户接口，变更-传播机制确保了用户接口和模型间的一致性。  </p>
<p>将各模块分层相互独立，降低耦合度，提高灵活性。<br>分层有助于管理复杂的应用程序，并且可以简化分组开发，不同开发人员可同时开发这些模块<br>可以提高有大量界面且业务复杂的大型程序的健壮性。</p>
<h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>模式将交互式程序分为三个部分：处理、输出、输入。  </p>
<p>各模型职责如下(按层序排列)：</p>
<ul>
<li>视图：显示数据，依据模型数据创建。一个模型可以有多个视图。   </li>
<li>控制器：处理用户交互，接受事件，向变更-传播机制注册自己并实现更新过程。本身并不输出任何东西也不做任何处理，只接收请求并决定由哪个模型去处理请求，然后再确定由哪个视图来显示数据。每个视图都有一个相关的控制器，用户通过控制器与系统交互。  </li>
<li>模型：用于处理程序的数据逻辑，通常负责在数据库中存取数据。模型与数据格式无关，可以为多个视图提供数据。注意这个需要处理的是逻辑和数据，包括了三层架构中的BLL、DAL、Model。  </li>
</ul>
<p>允许同一个模型有多个视图，如果用户通过一个视图的控制器改变了模型，所有依赖于该数据的其它视图应该反映出这种变化，当模型的数据改变时，需要通报所有视图。  </p>
<p>在初始化阶段，所有视图需要向变更-传播机制注册，每个视图创建一个合适的控制器（一对一的关系）。</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>可以按如下步骤创建：</p>
<ol>
<li>将人机交互从核心功能中分离出来</li>
<li>实现变更-传播机制<br> 可以用出版者-订阅者/观察者来实现</li>
<li>设计并实现视图</li>
<li>设计并实现控制器<br> 对每个视图指定回应用户动作的行为。</li>
<li>设计并实现视图-控制器关系<br> 可以用工厂方法来关联其关系</li>
<li>实现MVC初始化代码<br> 首先初始化模型、然后创建并初始化视图，之后进入循环事件处理。</li>
<li>创建动态视图<br> 如果允许动态打开关闭视图，可以创建一个视图管理者</li>
<li>可替换控制器<br> 可以对一个视图替换多个控制器，比如可以替换只读控制器来使视图只读。</li>
<li>层次化视图和控制器的结构</li>
<li>进一步去除系统依赖性</li>
</ol>
<p>书中的uml类图大致是这样：<br>View和Controller继承公共父类Observer（不需要独立的观察者）。Controller需要Model、View，View需要Model，Model可以注册Observer。  </p>
<p>在构建View的时候需要传入Model并向Model注册自身；构建Controller时需要传入View，从View取得Model并注册自身；或者可以在View中桥接Controller。<br>用户操作都由控制器处理，根据事件修改模型，在模型被修改后，它会通知视图更新显示。</p>
<p>如果显示和事件处理交织在一起，可以牺牲控制器的可交换性将视图和控制器合并，这种结构称为文档-视图。</p>
<h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>提高可重用性、松耦合、提高灵活性和配置性</p>
<hr>
<h2 id="表示-抽象-控制（Presentation-Abstraction-Control，PAC）"><a href="#表示-抽象-控制（Presentation-Abstraction-Control，PAC）" class="headerlink" title="表示-抽象-控制（Presentation-Abstraction-Control，PAC）"></a>表示-抽象-控制（Presentation-Abstraction-Control，PAC）</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>以多层合作代理人（agent）的方式定义了交互式软件系统的一种结构，每个代理人负责应用程序的某一特定功能，并且由表示、抽象、控制组成，这种细分将人机交互部分 与 功能内核 和 代理的通信分隔开来。</p>
<h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>这个结构可对系统进行横向和纵向分解。它为某一特定的任务制定一个agent，所有的agent共同提供整个系统的功能。<br>每个agent都维护它自身的状态和数据，所以agent之间需要有一个交换数据、消息和事件的机制。它们各自的人机交互方式常常差别较大，所以它们各自有各自的用户接口。使用这个结构，在替换agent时不会影响到整个系统。  </p>
<p>这个模式用<strong>树状</strong>层次结构构建交互式程序。它设置一个顶层，几个中间层和较多的底层agent，它们各自负责应用功能的某一特定方面，并且<strong>每一个agent都由PAC三部分组成</strong>。每个agent都依赖所有较上层的agent直到顶层。</p>
<p>agent的<strong>表示</strong>组件提供了<strong>可视行为</strong>；<strong>抽象</strong>组件构成<strong>数据模型</strong>，并可对这些数据进行操作；<strong>控制</strong>组件<strong>连接</strong> <strong>表示与抽象</strong>组件，并提供与其它agent<strong>通信</strong>的功能。</p>
<p><strong>顶层</strong><br>提供系统功能核心，控制结构层，其它绝大部分agent都依赖于它。</p>
<ul>
<li>表示组件：通常没有什么职责，它可能包含共有的一些用户接口元素，在某些系统中可以没有顶层表示组件。</li>
<li>抽象组件：提供全局数据模型，提供操纵数据模型和检索信息的功能。  </li>
<li>控制组件：允许低层使用顶层的服务（存取和操纵全局数据模型），低层的服务请求被提交给抽象组件或表示组件。<br>  保存顶层和低层之间的连接信息，控制组件用这些信息确保顶层和低层之间的正确协作和数据交换。<br>  保存用户与系统的交互信息，可以跟踪调用，以提供对核心操作的历史记录或取消/重做功能。  </li>
</ul>
<p><strong>底层</strong><br>提供具体视图，系统的用户仅和底层交互。</p>
<ul>
<li>表示组件：输出具体视图。</li>
<li>抽象组件：维护组件自身的数据。  </li>
<li>控制组件：维护表示和抽象，避免它们之间直接依赖。与较高层agent通信以交换事件和数据，输入<strong>事件</strong>被传送到底层的表示组件，输入<strong>数据</strong>被传送到底层的抽象组件，输出的<strong>事件和数据</strong>被发送到高层agent。  </li>
</ul>
<p><strong>中层</strong><br>可完成两种不同的任务：合成与协作。<br>协调低层，并将它们组合成较高层次的抽象。</p>
<ul>
<li>表示组件：实现用户接口。</li>
<li>抽象组件：维护中层组件自身的数据。</li>
<li>控制组件：类似底层和顶层的职责。协调从属的agent，将顶层数据模型发生的变化通知给底层，并组织它们刷新。</li>
</ul>
<p>我<strong>自己的理解</strong>是（可能不对）：每一个agent都有表示-抽象-控制三个部分组成，多个agent组成树，也就是整个系统。在每一个agent中，用控制层解耦表示和抽象层。在构成整个系统的树中分为三层，顶层用来管理数据并提供管理接口，底层是显示数据和接收用户操作事件，中层解耦顶层和底层并定义不同的功能扩展方向。<br>在调用时，由中层决定具体操作的底层对象，并向顶层获取数据，然后再将具体数据传递给底层显示。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>需要如下的步骤，必要时可重复其中的某些步骤：</p>
<ol>
<li>定义应用模型<br> 分析系统应该提供哪些服务，需要哪些组件，各组件之间如何协作，操作哪些数据，用户如何交互等。  </li>
<li>定义分层策略<br> 将共有服务提取到上层，全局服务放到顶层。注意层次越深越难维护，但是分多层可以更好的区分概念，这需要做权衡。</li>
<li>明确顶层内容<br> 确定系统核心的部分内容，明确这些公共接口，这些都将是顶层的一部分。</li>
<li>明确底层内容<br> 将模型组件分成最小的独立单元，确定每一个单元提供的人机交互组件，并使每一个语义概念都是一个独立的底层agent。  </li>
<li>明确系统服务的底层agent<br> 对于每一个服务，都可作为一个独立的底层agent。 </li>
<li>明确组合低层agent的中间层<br> 将几个低层组合成高层语义，并提供人机交互，使中间层可以基于它们组合的较低层agent进行操作。  </li>
<li>明确与较低层协作的中间层<br> 协调较低层的操作，比如视图显示，当一个视图的数据发生变化时，其它视图中的数据也必须更新。  </li>
<li>将核心功能从人机交互分离出来<br> 为每个agent引入表示组件和抽象组件，将表示数据分到表示部分，核心数据或操作分到抽象部分。可以使用外观模式给抽象和表示组件提供一个统一接口。然后引入控制组件来避免它们之间的直接依赖关系。</li>
<li>提供外部接口<br> 这个功能是控制组件的一部分，控制组件是一个中介者（或者可以用出版者订阅者的方式），它可以将输入事件传递到期望的接受者，比如抽象组件或表示组件，也可以是低层或高层。对于所有agent，其通信和协作功能的接口都是相同的。</li>
<li>将各层次连接起来<br>将每个agent和与它直接协作的低层agent连接起来，并且允许动态的创建和删除低层agent，这些低层有动态扩展或减少层次的功能。当用户需要某个功能时就创建一个新的agent，不需要时就删除它。</li>
</ol>
<h3 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h3><p>可以配合一些并行模式（比如主动对象、半同步/半异步）使用，agent可以作为进程使用。</p>
<h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>事务分离、支持变化和扩展、支持多任务</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>系统复杂、控制复杂、agent之间的通信开销可能会影响系统效率</p>
<hr>
<h1 id="适应性系统"><a href="#适应性系统" class="headerlink" title="适应性系统"></a>适应性系统</h1><p>在设计期间可以应对软件系统的变化。</p>
<h2 id="微核（Microkernel）"><a href="#微核（Microkernel）" class="headerlink" title="微核（Microkernel）"></a>微核（Microkernel）</h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><p>用于必须能够适应变更系统需求的软件系统。它把最小功能核心从扩展功能和特定客户部分分离出来，它也可以作为插入到这些扩展中并协调其协作的组件。</p>
<h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>将平台上的基本服务封装到一个微核组件中，该组件包含进程间通信的功能，并且负责维护系统资源和提供存取接口给其它组件。<br>不能在微核中实现的核心功能应该分到内部服务器中，外部服务器实现了它们自己的微核结构，每个外部服务器是一个独立进程，该进程表示一个应用程序平台。一个微核系统可以被视为集成了其它应用程序平台的平台。客户机通过使用由微核提供的通信能力与外部通信。  </p>
<p>有5个参与组件：</p>
<ul>
<li>微核：主要组件。实现了通信和资源处理机制，其它组件全部或部分建立在这个基本服务之上。许多系统特定的内容都被封装在内，维护像进程或文件那样的系统资源，并控制和协调对这些资源的访问。</li>
<li>内部服务器：扩展微核提供的功能，实现附加服务，封装某些系统特性。内部服务器只能由微核访问。目标是减小微核的存储需求和减少服务执行时间。</li>
<li>外部服务器：用微核实现，为客户提供编程接口。每个这样的外部服务器运行在一个独立进程上，通过由微核提供的通信手段接收来自客户机程序的服务请求，并解析和执行相应的服务，然后把结果发回客户机。</li>
<li>客户机：与外部服务器精确关联的程序，只使用外部服务器提供的编程接口。</li>
<li>适配器（也称仿真器）：避免客户机与外部服务器之间的直接依赖性。隐藏客户机的通信手段。如果外部服务器实现了一个现有的应用程序平台，那么相应的适配器会参照这个平台的编程接口实现。当客户机向外部服务器请求服务时，适配器会使用微核提供的通信服务把调用提交给合适的服务器。  </li>
</ul>
<p>自己的理解：程序使用适配器提供的接口，当需要某些调用时适配器会使用微核提供的外部服务器的服务，这样替换/修改微核就可以适应系统变更。  </p>
<h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><p>可移植性、适应性和可扩展性</p>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>性能会有一定影响</p>
<hr>
<h2 id="映像（Reflection）"><a href="#映像（Reflection）" class="headerlink" title="映像（Reflection）"></a>映像（Reflection）</h2><p>开放实现（Open Implementation）/元层次架构（Meta-Level Architecture）</p>
<h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><p>为动态改变软件系统的结构和行为提供了一种机制。它支持诸如类型结构和函数调用机制等基本方面的修改。  </p>
<h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><p>在这种模式中，一个应用程序可以分成两部分：</p>
<ul>
<li>元层次：封装可更改的系统内部信息，提供所选系统属性的相关信息并使软件含自述信息；由元对象组成，它封装和表达了有关软件的信息；提供一个接口以方便对元层次修改</li>
<li>基本层次：包括应用程序逻辑，它的实现建立在元层次之上，改变保存在元层次上的信息会影响基本层次的行为（不需修改基本层次的代码）</li>
</ul>
<p>操作元对象的接口被称为<strong>元对象协议</strong>，它为元层次的变更提供一个接口，并负责检查变化的正确性，并完成这个变更。<br>它常被设计为一个独立组件。它需要访问元对象的内部状态，可以为它提供一个只有它才能访问的元对象接口。</p>
<p>每个元对象封装了一个关于基本层的结构、行为或状态的信息，这个信息可以由系统运行期间的环境提供或从基本层获得，或者由用户定义。所有元对象构成程序的自述信息。元对象使原本需要间接获得的信息变得可直接存取和修改。<br>其它基本层的组件可以用这些元对象来确定它们的通信对象是远程还是本地的，它们可以选择最有效的函数调用机制与对方通信，这个调用机制可能由其它元对象提供。</p>
<p>元对象不允许基本层次修改其内部状态，需要通过元对象协议才能修改。<br>基本层使用元对象提供的信息和服务，并且不需要关心它的通信对象的具体位置。<br>基本层使用元对象来实现程序逻辑，但它们不能直接更改元对象，需要通过元对象协议来修改。</p>
<h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><p>修改系统时不需要接触现有源代码，使更改系统变得简单</p>
<h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>效率会低一些</p>
<!--

---
# 前端控制器（Front controller）
-->
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright box-shadow">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Nargnos
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/2017/09/03/学习笔记/模式/架构型/" title="[模式] 架构型">/2017/09/03/学习笔记/模式/架构型/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/模式/" class="fa fa-tag" rel="tag"> 模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/28/学习笔记/模式/并发型/" rel="next" title="[模式] 并发型">
                <i class="fa fa-chevron-left"></i> [模式] 并发型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/07/其它/微调了一下模板/" rel="prev" title="微调了一下模板">
                微调了一下模板 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Nargnos" />
          <p class="site-author-name" itemprop="name">Nargnos</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从混乱到有序"><span class="nav-number">1.</span> <span class="nav-text">从混乱到有序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#层次（Layers）"><span class="nav-number">1.1.</span> <span class="nav-text">层次（Layers）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用"><span class="nav-number">1.1.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">1.1.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展"><span class="nav-number">1.1.4.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">1.1.5.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.6.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三层架构"><span class="nav-number">1.1.7.</span> <span class="nav-text">三层架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道和过滤器（Pipes-and-Filters）"><span class="nav-number">1.2.</span> <span class="nav-text">管道和过滤器（Pipes and Filters）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-1"><span class="nav-number">1.2.5.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-1"><span class="nav-number">1.2.6.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#黑板（Blackboard）"><span class="nav-number">1.3.</span> <span class="nav-text">黑板（Blackboard）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-2"><span class="nav-number">1.3.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-2"><span class="nav-number">1.3.4.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-2"><span class="nav-number">1.3.5.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式系统"><span class="nav-number">2.</span> <span class="nav-text">分布式系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代理者（Broker）"><span class="nav-number">2.1.</span> <span class="nav-text">代理者（Broker）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-3"><span class="nav-number">2.1.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-3"><span class="nav-number">2.1.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-3"><span class="nav-number">2.1.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-3"><span class="nav-number">2.1.4.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-3"><span class="nav-number">2.1.5.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交互式系统"><span class="nav-number">3.</span> <span class="nav-text">交互式系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模型-视图-控制器（Model-View-Controller，MVC）"><span class="nav-number">3.1.</span> <span class="nav-text">模型-视图-控制器（Model-View-Controller，MVC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-4"><span class="nav-number">3.1.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-4"><span class="nav-number">3.1.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-4"><span class="nav-number">3.1.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-4"><span class="nav-number">3.1.4.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表示-抽象-控制（Presentation-Abstraction-Control，PAC）"><span class="nav-number">3.2.</span> <span class="nav-text">表示-抽象-控制（Presentation-Abstraction-Control，PAC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-5"><span class="nav-number">3.2.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-5"><span class="nav-number">3.2.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-5"><span class="nav-number">3.2.3.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展-2"><span class="nav-number">3.2.4.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-5"><span class="nav-number">3.2.5.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-4"><span class="nav-number">3.2.6.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#适应性系统"><span class="nav-number">4.</span> <span class="nav-text">适应性系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#微核（Microkernel）"><span class="nav-number">4.1.</span> <span class="nav-text">微核（Microkernel）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-6"><span class="nav-number">4.1.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-6"><span class="nav-number">4.1.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-6"><span class="nav-number">4.1.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-5"><span class="nav-number">4.1.4.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#映像（Reflection）"><span class="nav-number">4.2.</span> <span class="nav-text">映像（Reflection）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用-7"><span class="nav-number">4.2.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-7"><span class="nav-number">4.2.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点-7"><span class="nav-number">4.2.3.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-6"><span class="nav-number">4.2.4.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








<!--and theme.scheme === 'Pisces'-->

  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js" id="ribbon" size="100" alpha='0.6' zIndex="-2"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
